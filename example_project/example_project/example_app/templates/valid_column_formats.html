{% extends "base.html" %}

{% block content %}
    <h2>Deprecated column definition guide</h2>

    <p>
        Before version 0.9 and the <code>Datatable</code> configuration class it introduced, all
        options had to be specified in one big dictionary and assigned as an attribute on the view.
        For simple tables, view attributes weren't that so bad, but it didn't take much to get
        out of control.  You should avoid using it when building new tables.
    </p>

    <p>
        Using this configuration style, you name a model field and the table would find the model
        field's verbose name for display purposes.  To use a custom verbose name, or if the column
        needed to show more than one model field worth of data (a method, property, two concatenated
        field values, etc) then the column had to become a 2- or 3-tuple of settings.
    </p>

    <p>
        The following formats are all valid (but deprecated) ways to write a column definition on
        a ``LegacyConfigurationDatatableView`` or ``LegacyDatatableView``, via the
        <code>datatable_options</code> class attribute dict:
    </p>
    <pre class="brush: python">
datatable_options = {
    'columns': [
        # "concrete" field backed by the database
        'name',  # field's verbose_name will be used
        ("Name", 'name'),  # custom verbose name provided
        ("Name", 'name', 'callback_attr_name'),  # callback looked up on view
        ("Name", 'name', callback_handle),  # calback used directly

        # non-field, but backed by methods, properties, etc
        "Virtual Field",

        # "fake" virtual field whose data is generated by the view
        ("Virtual Field", None, 'callback_attr_name'),
        ("Virtual Field", None, callback_handle),
    ],
}
    </pre>

    <p>
        For concrete fields that also provide callbacks, the actual database value will be consulted
        during searches and sorts, but the table will use the return value of the callback as the
        display data.
    </p>

    <p>
        Virtual fields are useful ways to mount methods onto a table.  Consider a read-only property
        that generates its return value based on some underlying database field:
    </p>
    <pre class="brush: python">
datatable_options = {
    'columns': [
        ("Average profit", 'get_average_profit'),
    ],
}
    </pre>
    
    <p class="alert alert-warning">
        Be careful with virtual columns that might cause database queries per-row.  That doesn't
        scale very well!
    </p>
{% endblock content %}
